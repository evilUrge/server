# the following 3 imports are needed for blobcache
from __future__ import with_statement
import cloudstorage as gcs

import datetime
import logging
import pickle

from google.appengine.api import memcache
from google.appengine.ext import db

from app import App
import request_cache

BLOBCACHE_BUCKET = "blobcache"
if App.is_dev_server:
    # cachepy disables itself during development presumably to avoid confusion.
    # Instead, alias it to request_cache. This means individual requests will
    # behave more like production, but the cache will be flushed after a request.
    import request_cache as cachepy
else:
    import cachepy
    from google.appengine.api.app_identity import get_application_id
    try:
        app_id = get_application_id()
    except AttributeError:
        BLOBCACHE_BUCKET += "-error"
    else:
        if app_id.endswith("-dev"):
            BLOBCACHE_BUCKET += "-dev"


# layer_cache provides an easy way to cache the result of functions across requests.
# layer_cache uses cachepy's in-memory storage, memcache, and the datastore.
#
# Unless otherwise specified, memcache and in-memory storage are used.
# The datastore layer must be explicitly requested.
#
# When using layer_cache, you can specify which layers to make use of depending on your
# individual use and the need for speed and memory.
#
# _____Explanation by examples:_____
#
# Cache in both memcache and cachepy the result of
# this long-running function using a static key,
# and return the result when available instead of recalculating:
#
# import layer_cache
#
# @layer_cache.cache()
# def calculate_user_averages():
#    ...do lots of long-running work...
#    return result_for_cache
#
#
# and with expiration every minute:
#
# @layer_cache.cache(expiration=60)
# def calculate_user_averages():
#    ...do lots of long-running work...
#    return result_for_cache
#
# Cache using key generated by utility function that
# varies the key based on the function's input parameters:
#
# @layer_cache.cache_with_key_fxn(lambda object: "layer_cache_key_for_object_%s" % object.id())
# def calculate_object_average(object):
#   ... do lots of long-running work...
#   return result_for_cache
#
# _____Manually busting the cache:_____
#
# When you call your cached function, just pass a special "bust_cache"
# named parameter to ignore any existing cached values and replace
# with whatever is newly returned:
#
# calculate_object_average(object, bust_cache=True)
#
# _____Other settings/options:_____
#
# Only cache in datastore:
# @layer_cache.cache(... layer=layer_cache.Layers.Datastore)
#
# Only cache in memcache:
# @layer_cache.cache(... layer=layer_cache.Layers.Memcache)
#
# Only cache in cachepy's in-app memory cache:
# @layer_cache.cache(... layer=layer_cache.Layers.InAppMemory)
#
# Only cache in memcache and datastore:
# @layer_cache.cache(... layer=layer_cache.Layers.Memcache | layer_cache.Layers.Datastore)
#
# Persist the cached values across different uploaded app verions (disabled by default):
# @layer_cache.cache(... persist_across_app_versions=True)
#
# If key has expired or is no longer in the current cache and throws an error when trying to be recomputed, then try getting resource from permanent key that is not set to expire
# @layer_cache.cache(... expiration=60, permanent_cache_key = lambda object: "permanent_layer_cache_key_for_object_%s" % object.id())
#
# _____Disabling:_____
#
# You can disable layer_cache for the rest of the request by calling:
# layer_cache.disable()
# 
# Re-enable it with
# layer_cache.enable()


DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS = 60 * 60 * 24 * 25 # Expire after 25 days by default

class Layers:
    Datastore = 1
    Memcache = 2
    InAppMemory = 4
    Blobstore = 8

def disable():
    request_cache.set("layer_cache_disabled", True)

def enable():
    request_cache.set("layer_cache_disabled", False)

def is_disabled():
    return request_cache.get("layer_cache_disabled") or False

def cache(
        expiration = DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS,
        layer = Layers.Memcache | Layers.InAppMemory,
        persist_across_app_versions = False,
        bigdata = False,
        ):
    def decorator(target):
        key = "__layer_cache_%s.%s__" % (target.__module__, target.__name__)
        def wrapper(*args, **kwargs):
            return layer_cache_check_set_return(target, lambda *args, **kwargs: key, expiration, layer, persist_across_app_versions, None, bigdata, *args, **kwargs)
        return wrapper
    return decorator

def cache_with_key_fxn(
        key_fxn,
        expiration = DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS,
        layer = Layers.Memcache | Layers.InAppMemory,
        persist_across_app_versions = False,
        permanent_key_fxn = None,
        bigdata = False,
        ):
    def decorator(target):
        def wrapper(*args, **kwargs):
            return layer_cache_check_set_return(target, key_fxn, expiration, layer, persist_across_app_versions, permanent_key_fxn, bigdata, *args, **kwargs)
        return wrapper
    return decorator

import cPickle
def big_memcache_set(key, value, chunksize=950000, **kw):
    serialized = cPickle.dumps(value, cPickle.HIGHEST_PROTOCOL)
    size = len(serialized)
    if size//chunksize>32:
        raise Exception("value is way too big for memcache (%s)", size)
    values = {}
    for i, offset in enumerate(xrange(0, size, chunksize)):
        values[str(i)] = serialized[offset:offset+chunksize]
    not_set = memcache.set_multi(values, key_prefix=key, **kw)
    return not not_set # an empty list means success

def big_memcache_get(key, **kw):
    result = memcache.get_multi([str(i) for i in xrange(32)], key_prefix=key, **kw).items()
    result.sort()
    serialized = ''.join([v for (k,v) in result if v is not None])
    if serialized:
        return cPickle.loads(serialized)

def layer_cache_check_set_return(
        target,
        key_fxn,
        expiration = DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS,
        layer = Layers.Memcache | Layers.InAppMemory,
        persist_across_app_versions = False,
        permanent_key_fxn = None,
        bigdata = False,
        *args,
        **kwargs):

    if bigdata:
        get_from_memcache = big_memcache_get
        set_to_memcache = big_memcache_set
    else:
        get_from_memcache = memcache.get
        set_to_memcache = memcache.set

    def get_cached_result(key, namespace, expiration, layer):

        if layer & Layers.InAppMemory:
            result = cachepy.get(key)
            if result is not None:
                return result

        if layer & Layers.Memcache:
            result = get_from_memcache(key, namespace=namespace)
            if result is not None:
                # Found in memcache, fill upward layers
                if layer & Layers.InAppMemory:
                    cachepy.set(key, result, expiry=expiration)
                return result

        if layer & Layers.Datastore:
            result = KeyValueCache.get(key, namespace=namespace)
            if result is not None:
                # Found in datastore, fill upward layers
                if layer & Layers.InAppMemory:
                    cachepy.set(key, result, expiry=expiration)
                if layer & Layers.Memcache:
                    set_to_memcache(key, result, time=expiration, namespace=namespace)
                return result

        if layer & Layers.Blobstore:
            result = BlobCache.get(key, namespace=namespace)
            # TODO: fill upward layers if size of dumped result is going to be less than 1MB (might be too costly to figure that out
            return result


    def set_cached_result(key, namespace, expiration, layer, result):
        # Cache the result
        if layer & Layers.InAppMemory:
            cachepy.set(key, result, expiry=expiration)

        if layer & Layers.Memcache:
            if not set_to_memcache(key, result, time=expiration, namespace=namespace):
                logging.error("Memcache set failed for %s" % key)

        if layer & Layers.Datastore:
            KeyValueCache.set(key, result, time=expiration, namespace=namespace)

        if layer & Layers.Blobstore:
            BlobCache.set(key, result, time=expiration, namespace=namespace)

    bust_cache = False
    if "bust_cache" in kwargs:
        bust_cache = kwargs["bust_cache"]
        # delete from kwargs so it's not passed to the target
        del kwargs["bust_cache"]

    key = key_fxn(*args, **kwargs)

    # if key is None, or layer_cache is disabled don't bother trying to get it 
    # from the cache, just execute the function and return it
    if key is None or request_cache.get("layer_cache_disabled"):
        return target(*args, **kwargs)

    namespace = App.version

    if persist_across_app_versions:
        namespace = None

    if not bust_cache:
        try:
            result = get_cached_result(key, namespace, expiration, layer)
        except IOError:
            logging.exception("Exception loading from %s cache", key)
            result = None
        if result is not None:
            return result

    try:
        result = target(*args, **kwargs)

    # an error happened trying to recompute the result, see if there is a value for it in the permanent cache
    except Exception, e:
        import traceback, StringIO
        fp = StringIO.StringIO()
        traceback.print_exc(file=fp)
        logging.error("Error fetching from cache (key=%s)", key)
        logging.error(fp.getvalue())

        if permanent_key_fxn is not None:
            permanent_key = permanent_key_fxn(*args, **kwargs)

            result = get_cached_result(permanent_key, namespace, expiration, layer)

            if result is not None:
                logging.info("resource is not available, restoring from permanent cache")

                # In case the key's value has been changed by target's execution
                key = key_fxn(*args, **kwargs)

                #retreived item from permanent cache - save it to the more temporary cache and then return it
                set_cached_result(key, namespace, expiration, layer, result)
                return result

        # could not retrieve item from a permanent cache, raise the error on up
        raise e

    if isinstance(result, UncachedResult):
        # Don't cache this result, just return it
        result = result.result
    else:
        if permanent_key_fxn is not None:
            permanent_key = permanent_key_fxn(*args, **kwargs)
            set_cached_result(permanent_key, namespace, 0, layer, result)

        # In case the key's value has been changed by target's execution
        key = key_fxn(*args, **kwargs)
        set_cached_result(key, namespace, expiration, layer, result)

    return result

# Functions can return an UncachedResult-wrapped object
# to tell layer_cache to skip caching this specific result.
#
# Example:
#
# @layer_cache.cache()
# def slow_and_dangerous():
#   try:
#       return SomethingDangerous()
#   catch:
#       return UncachedResult(SomethingSafe())
#
class UncachedResult():
    def __init__(self, result):
        self.result = result

class KeyValueCache(db.Model):

    value = db.BlobProperty()
    created = db.DateTimeProperty()
    expires = db.DateTimeProperty()

    def is_expired(self):
        return datetime.datetime.now() > self.expires

    @staticmethod
    def get_namespaced_key(key, namespace=""):
        return "%s:%s" % (namespace, key)

    @staticmethod
    def get(key, namespace=""):

        namespaced_key = KeyValueCache.get_namespaced_key(key, namespace)
        key_value = KeyValueCache.get_by_key_name(namespaced_key)

        if key_value and not key_value.is_expired():
            return pickle.loads(key_value.value)

        return None

    @staticmethod
    def set(key, result, time=DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS, namespace=""):

        namespaced_key = KeyValueCache.get_namespaced_key(key, namespace)
        dt = datetime.datetime.now()

        dt_expires = datetime.datetime.max
        if time > 0:
            dt_expires = dt + datetime.timedelta(seconds=time)

        key_value = KeyValueCache.get_or_insert(
                key_name = namespaced_key,
                value = pickle.dumps(result),
                created = dt,
                expires = dt_expires)

        if key_value.created != dt:
            # Already existed, need to overwrite
            key_value.value = pickle.dumps(result)
            key_value.created = dt
            key_value.expires = dt_expires
            key_value.put()

    @staticmethod
    def delete(key, namespace=""):

        namespaced_key = KeyValueCache.get_namespaced_key(key, namespace)
        key_value = KeyValueCache.get_by_key_name(namespaced_key)

        if key_value:
            db.delete(key_value)

class BlobCache():

    @staticmethod
    def get_filename(key, namespace="all"):
        return "/%s/%s/%s" % (BLOBCACHE_BUCKET, namespace, key)


    @staticmethod
    def get(key, namespace="all"):
        try:
            blob = gcs.open(BlobCache.get_filename(key, namespace))
        except gcs.NotFoundError:
            return

        with blob as f:
            obj = pickle.load(f)
        return obj
       
    @staticmethod
    def set(key, result, time=DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS, namespace="all"):
        # old_blob_infos = BlobCache.get_blob_infos(key, namespace)
        # filename = BlobCache.get_filename(key, namespace)
        # return gcs.listbucket(filename).fetch(100)
      
        value = pickle.dumps(result)
        
        # Create the file
        filename = BlobCache.get_filename(key, namespace)
        gcs_file = gcs.open(filename, 'w', content_type='application/octet-stream')
 
        # might need to wrap it in an object to handle expiration time here
        
        # write the pickled result to the file
        pos = 0
        chunkSize = 65536
        with gcs_file as f:
            for pos in range(0, len(value), chunkSize):
                f.write(value[pos:pos+chunkSize])

        # # Get the file's blob key
        # blob_key = files.blobstore.get_blob_key(file_name)

        # for info in old_blob_infos:
        #     try:
        #         info.delete()
        #     except Exception, e:
        #         # If deleting blob times out, don't crash the request. Just log the error.
        #         logging.error("Failed to delete old blob from layer_cache: %s" % e)

    @staticmethod
    def delete(key, namespace="all"):
        filename = BlobCache.get_filename(key, namespace)
        gcs.delete(filename)
